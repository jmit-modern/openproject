{"version":3,"sources":["./node_modules/codemirror/mode/stex/stex.js","./node_modules/codemirror/mode/haskell/haskell.js","./node_modules/codemirror/mode/python/python.js","./node_modules/codemirror/mode/handlebars/handlebars.js","./node_modules/codemirror/addon/mode/multiplex.js","./node_modules/codemirror/mode/sass/sass.js","./node_modules/codemirror/addon/mode/simple.js","./node_modules/codemirror/mode/ruby/ruby.js","./node_modules/codemirror/addon/mode/overlay.js","./node_modules/codemirror/mode/coffeescript/coffeescript.js","./node_modules/codemirror/mode/yaml/yaml.js"],"names":["CodeMirror","defineMode","_config","parserConfig","pushCommand","state","command","cmdState","push","peekCommand","length","addPluginPattern","pluginName","cmdStyle","styles","this","name","bracketNo","style","argument","styleIdentifier","openBracket","closeBracket","plugins","setState","f","normal","source","plug","match","cmdName","current","slice","beginParams","inMathMode","ch","next","skipToEnd","test","eatWhile","context","i","getMostPowerful","endModeSeq","eatSpace","peek","eat","pop","popCommand","startState","copyState","s","token","stream","blankLine","lineComment","defineMIME","mod","modeConfig","switchState","smallRE","largeRE","digitRE","hexitRE","octitRE","idRE","symbolRE","specialRE","whiteCharRE","t","ncomment","type","nest","currNest","eol","stringLiteral","stringGap","wellKnownWords","wkw","setType","arguments","override","overrideKeywords","word","hasOwnProperty","w","blockCommentStart","blockCommentEnd","wordRegexp","words","RegExp","join","str","wordOperators","commonKeywords","commonBuiltins","top","scopes","registerHelper","concat","conf","parserConf","ERRORCLASS","delimiters","singleDelimiters","operators","singleOperators","doubleOperators","doubleDelimiters","tripleDelimiters","splice","hangingIndent","indentUnit","myKeywords","myBuiltins","undefined","extra_keywords","extra_builtins","py3","version","Number","identifiers","stringPrefixes","keywords","builtins","tokenBase","sol","lastToken","indent","indentation","scopeOffset","offset","lineOffset","pushPyScope","dedent","errorToken","tokenBaseInner","floatLiteral","intLiteral","toLowerCase","indexOf","tokenize","delimiter","tokenOuter","charAt","substr","singleline","OUTCLASS","tokenNestedExpr","depth","inner","tokenString","singleLineStringErrors","isString","formatStringFactory","tokenStringFactory","align","indented","tokenLexer","beginningOfLine","lambda","delimiter_index","column","pushBracketScope","basecolumn","addErr","textAfter","Pass","scope","closing","electricInput","closeBrackets","triples","fold","split","defineSimpleMode","start","regex","handlebars_raw","handlebars","dash_comment","comment","meta","config","getMode","base","multiplexingMode","open","close","mode","parseDelimiters","outer","others","Array","prototype","call","string","pattern","from","returnEnd","found","m","exec","index","innerActive","curInner","oldContent","pos","delimStyle","innerToken","innerStyle","cutOff","Infinity","other","outerIndent","possibleOuterIndent","outerToken","line","electricChars","innerMode","cssMode","mimeModes","propertyKeywords","colorKeywords","valueKeywords","fontProperties","keywordsRegexp","opRegexp","pseudoElementsRegexp","isEndLine","urlTokens","tokenizer","buildStringTokenizer","multiLine","skipTo","quote","greedy","stringTokenizer","nextChar","peekChar","previousChar","cursorHalf","buildInterpolationTokenizer","currentTokenizer","indentCount","currentOffset","unshift","shift","prevProp","prop","definedVars","definedMixins","withCurrentIndent","newScopes","content","ensureState","states","Error","toRegex","val","caret","flags","ignoreCase","String","Rule","data","apply","replace","result","asToken","tokenFunction","pending","pend","text","local","end","tok","endToken","localState","endScan","curState","rule","matches","stack","enterLocalMode","j","backUp","cmp","a","b","props","spec","pers","persistent","p","persistentStates","lState","forceEnd","indentFunction","dontIndentStates","arr","rules","scan","dedentIfLineStart","simpleMode","states_","hasIndentation","list","orig","wordObj","o","e","curPunc","indentWords","dedentWords","opening","chain","newtok","readBlockComment","phrase","mayIndent","readQuoted","escaped","regexpAhead","embed","delim","propertyIsEnumerable","varList","lastTok","more","tokenBaseUntilBrace","tokenBaseOnce","alreadyCalled","unescaped","prev","continuedLine","kwtype","thisTok","firstChar","ct","closed","overlayMode","overlay","combine","basePos","baseCur","overlayPos","overlayCur","streamSeen","Math","min","combineTokens","baseToken","overlayToken","atProp","indentKeywords","regexPrefixes","constants","longComment","tokenFactory","outclass","alignOffset","_indent","matched","fillAlign","closer","closes","keywordRegex","esc","literal","keyCol","pair","pairStart","inlinePairs","inlineList"],"mappings":"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","file":"common.3a10411beb65f00e02af.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/*\n * Author: Constantin Jucovschi (c.jucovschi@jacobs-university.de)\n * Licence: MIT\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"stex\", function(_config, parserConfig) {\n    \"use strict\";\n\n    function pushCommand(state, command) {\n      state.cmdState.push(command);\n    }\n\n    function peekCommand(state) {\n      if (state.cmdState.length > 0) {\n        return state.cmdState[state.cmdState.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    function popCommand(state) {\n      var plug = state.cmdState.pop();\n      if (plug) {\n        plug.closeBracket();\n      }\n    }\n\n    // returns the non-default plugin closest to the end of the list\n    function getMostPowerful(state) {\n      var context = state.cmdState;\n      for (var i = context.length - 1; i >= 0; i--) {\n        var plug = context[i];\n        if (plug.name == \"DEFAULT\") {\n          continue;\n        }\n        return plug;\n      }\n      return { styleIdentifier: function() { return null; } };\n    }\n\n    function addPluginPattern(pluginName, cmdStyle, styles) {\n      return function () {\n        this.name = pluginName;\n        this.bracketNo = 0;\n        this.style = cmdStyle;\n        this.styles = styles;\n        this.argument = null;   // \\begin and \\end have arguments that follow. These are stored in the plugin\n\n        this.styleIdentifier = function() {\n          return this.styles[this.bracketNo - 1] || null;\n        };\n        this.openBracket = function() {\n          this.bracketNo++;\n          return \"bracket\";\n        };\n        this.closeBracket = function() {};\n      };\n    }\n\n    var plugins = {};\n\n    plugins[\"importmodule\"] = addPluginPattern(\"importmodule\", \"tag\", [\"string\", \"builtin\"]);\n    plugins[\"documentclass\"] = addPluginPattern(\"documentclass\", \"tag\", [\"\", \"atom\"]);\n    plugins[\"usepackage\"] = addPluginPattern(\"usepackage\", \"tag\", [\"atom\"]);\n    plugins[\"begin\"] = addPluginPattern(\"begin\", \"tag\", [\"atom\"]);\n    plugins[\"end\"] = addPluginPattern(\"end\", \"tag\", [\"atom\"]);\n\n    plugins[\"label\"    ] = addPluginPattern(\"label\"    , \"tag\", [\"atom\"]);\n    plugins[\"ref\"      ] = addPluginPattern(\"ref\"      , \"tag\", [\"atom\"]);\n    plugins[\"eqref\"    ] = addPluginPattern(\"eqref\"    , \"tag\", [\"atom\"]);\n    plugins[\"cite\"     ] = addPluginPattern(\"cite\"     , \"tag\", [\"atom\"]);\n    plugins[\"bibitem\"  ] = addPluginPattern(\"bibitem\"  , \"tag\", [\"atom\"]);\n    plugins[\"Bibitem\"  ] = addPluginPattern(\"Bibitem\"  , \"tag\", [\"atom\"]);\n    plugins[\"RBibitem\" ] = addPluginPattern(\"RBibitem\" , \"tag\", [\"atom\"]);\n\n    plugins[\"DEFAULT\"] = function () {\n      this.name = \"DEFAULT\";\n      this.style = \"tag\";\n\n      this.styleIdentifier = this.openBracket = this.closeBracket = function() {};\n    };\n\n    function setState(state, f) {\n      state.f = f;\n    }\n\n    // called when in a normal (no environment) context\n    function normal(source, state) {\n      var plug;\n      // Do we look like '\\command' ?  If so, attempt to apply the plugin 'command'\n      if (source.match(/^\\\\[a-zA-Z@]+/)) {\n        var cmdName = source.current().slice(1);\n        plug = plugins[cmdName] || plugins[\"DEFAULT\"];\n        plug = new plug();\n        pushCommand(state, plug);\n        setState(state, beginParams);\n        return plug.style;\n      }\n\n      // escape characters\n      if (source.match(/^\\\\[$&%#{}_]/)) {\n        return \"tag\";\n      }\n\n      // white space control characters\n      if (source.match(/^\\\\[,;!\\/\\\\]/)) {\n        return \"tag\";\n      }\n\n      // find if we're starting various math modes\n      if (source.match(\"\\\\[\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"\\\\]\"); });\n        return \"keyword\";\n      }\n      if (source.match(\"\\\\(\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"\\\\)\"); });\n        return \"keyword\";\n      }\n      if (source.match(\"$$\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"$$\"); });\n        return \"keyword\";\n      }\n      if (source.match(\"$\")) {\n        setState(state, function(source, state){ return inMathMode(source, state, \"$\"); });\n        return \"keyword\";\n      }\n\n      var ch = source.next();\n      if (ch == \"%\") {\n        source.skipToEnd();\n        return \"comment\";\n      } else if (ch == '}' || ch == ']') {\n        plug = peekCommand(state);\n        if (plug) {\n          plug.closeBracket(ch);\n          setState(state, beginParams);\n        } else {\n          return \"error\";\n        }\n        return \"bracket\";\n      } else if (ch == '{' || ch == '[') {\n        plug = plugins[\"DEFAULT\"];\n        plug = new plug();\n        pushCommand(state, plug);\n        return \"bracket\";\n      } else if (/\\d/.test(ch)) {\n        source.eatWhile(/[\\w.%]/);\n        return \"atom\";\n      } else {\n        source.eatWhile(/[\\w\\-_]/);\n        plug = getMostPowerful(state);\n        if (plug.name == 'begin') {\n          plug.argument = source.current();\n        }\n        return plug.styleIdentifier();\n      }\n    }\n\n    function inMathMode(source, state, endModeSeq) {\n      if (source.eatSpace()) {\n        return null;\n      }\n      if (endModeSeq && source.match(endModeSeq)) {\n        setState(state, normal);\n        return \"keyword\";\n      }\n      if (source.match(/^\\\\[a-zA-Z@]+/)) {\n        return \"tag\";\n      }\n      if (source.match(/^[a-zA-Z]+/)) {\n        return \"variable-2\";\n      }\n      // escape characters\n      if (source.match(/^\\\\[$&%#{}_]/)) {\n        return \"tag\";\n      }\n      // white space control characters\n      if (source.match(/^\\\\[,;!\\/]/)) {\n        return \"tag\";\n      }\n      // special math-mode characters\n      if (source.match(/^[\\^_&]/)) {\n        return \"tag\";\n      }\n      // non-special characters\n      if (source.match(/^[+\\-<>|=,\\/@!*:;'\"`~#?]/)) {\n        return null;\n      }\n      if (source.match(/^(\\d+\\.\\d*|\\d*\\.\\d+|\\d+)/)) {\n        return \"number\";\n      }\n      var ch = source.next();\n      if (ch == \"{\" || ch == \"}\" || ch == \"[\" || ch == \"]\" || ch == \"(\" || ch == \")\") {\n        return \"bracket\";\n      }\n\n      if (ch == \"%\") {\n        source.skipToEnd();\n        return \"comment\";\n      }\n      return \"error\";\n    }\n\n    function beginParams(source, state) {\n      var ch = source.peek(), lastPlug;\n      if (ch == '{' || ch == '[') {\n        lastPlug = peekCommand(state);\n        lastPlug.openBracket(ch);\n        source.eat(ch);\n        setState(state, normal);\n        return \"bracket\";\n      }\n      if (/[ \\t\\r]/.test(ch)) {\n        source.eat(ch);\n        return null;\n      }\n      setState(state, normal);\n      popCommand(state);\n\n      return normal(source, state);\n    }\n\n    return {\n      startState: function() {\n        var f = parserConfig.inMathMode ? function(source, state){ return inMathMode(source, state); } : normal;\n        return {\n          cmdState: [],\n          f: f\n        };\n      },\n      copyState: function(s) {\n        return {\n          cmdState: s.cmdState.slice(),\n          f: s.f\n        };\n      },\n      token: function(stream, state) {\n        return state.f(stream, state);\n      },\n      blankLine: function(state) {\n        state.f = normal;\n        state.cmdState.length = 0;\n      },\n      lineComment: \"%\"\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-stex\", \"stex\");\n  CodeMirror.defineMIME(\"text/x-latex\", \"stex\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haskell\", function(_config, modeConfig) {\n\n  function switchState(source, setState, f) {\n    setState(f);\n    return f(source, setState);\n  }\n\n  // These should all be Unicode extended, as per the Haskell 2010 report\n  var smallRE = /[a-z_]/;\n  var largeRE = /[A-Z]/;\n  var digitRE = /\\d/;\n  var hexitRE = /[0-9A-Fa-f]/;\n  var octitRE = /[0-7]/;\n  var idRE = /[a-z_A-Z0-9'\\xa1-\\uffff]/;\n  var symbolRE = /[-!#$%&*+.\\/<=>?@\\\\^|~:]/;\n  var specialRE = /[(),;[\\]`{}]/;\n  var whiteCharRE = /[ \\t\\v\\f]/; // newlines are handled in tokenizer\n\n  function normal(source, setState) {\n    if (source.eatWhile(whiteCharRE)) {\n      return null;\n    }\n\n    var ch = source.next();\n    if (specialRE.test(ch)) {\n      if (ch == '{' && source.eat('-')) {\n        var t = \"comment\";\n        if (source.eat('#')) {\n          t = \"meta\";\n        }\n        return switchState(source, setState, ncomment(t, 1));\n      }\n      return null;\n    }\n\n    if (ch == '\\'') {\n      if (source.eat('\\\\')) {\n        source.next();  // should handle other escapes here\n      }\n      else {\n        source.next();\n      }\n      if (source.eat('\\'')) {\n        return \"string\";\n      }\n      return \"string error\";\n    }\n\n    if (ch == '\"') {\n      return switchState(source, setState, stringLiteral);\n    }\n\n    if (largeRE.test(ch)) {\n      source.eatWhile(idRE);\n      if (source.eat('.')) {\n        return \"qualifier\";\n      }\n      return \"variable-2\";\n    }\n\n    if (smallRE.test(ch)) {\n      source.eatWhile(idRE);\n      return \"variable\";\n    }\n\n    if (digitRE.test(ch)) {\n      if (ch == '0') {\n        if (source.eat(/[xX]/)) {\n          source.eatWhile(hexitRE); // should require at least 1\n          return \"integer\";\n        }\n        if (source.eat(/[oO]/)) {\n          source.eatWhile(octitRE); // should require at least 1\n          return \"number\";\n        }\n      }\n      source.eatWhile(digitRE);\n      var t = \"number\";\n      if (source.match(/^\\.\\d+/)) {\n        t = \"number\";\n      }\n      if (source.eat(/[eE]/)) {\n        t = \"number\";\n        source.eat(/[-+]/);\n        source.eatWhile(digitRE); // should require at least 1\n      }\n      return t;\n    }\n\n    if (ch == \".\" && source.eat(\".\"))\n      return \"keyword\";\n\n    if (symbolRE.test(ch)) {\n      if (ch == '-' && source.eat(/-/)) {\n        source.eatWhile(/-/);\n        if (!source.eat(symbolRE)) {\n          source.skipToEnd();\n          return \"comment\";\n        }\n      }\n      var t = \"variable\";\n      if (ch == ':') {\n        t = \"variable-2\";\n      }\n      source.eatWhile(symbolRE);\n      return t;\n    }\n\n    return \"error\";\n  }\n\n  function ncomment(type, nest) {\n    if (nest == 0) {\n      return normal;\n    }\n    return function(source, setState) {\n      var currNest = nest;\n      while (!source.eol()) {\n        var ch = source.next();\n        if (ch == '{' && source.eat('-')) {\n          ++currNest;\n        }\n        else if (ch == '-' && source.eat('}')) {\n          --currNest;\n          if (currNest == 0) {\n            setState(normal);\n            return type;\n          }\n        }\n      }\n      setState(ncomment(type, currNest));\n      return type;\n    };\n  }\n\n  function stringLiteral(source, setState) {\n    while (!source.eol()) {\n      var ch = source.next();\n      if (ch == '\"') {\n        setState(normal);\n        return \"string\";\n      }\n      if (ch == '\\\\') {\n        if (source.eol() || source.eat(whiteCharRE)) {\n          setState(stringGap);\n          return \"string\";\n        }\n        if (source.eat('&')) {\n        }\n        else {\n          source.next(); // should handle other escapes here\n        }\n      }\n    }\n    setState(normal);\n    return \"string error\";\n  }\n\n  function stringGap(source, setState) {\n    if (source.eat('\\\\')) {\n      return switchState(source, setState, stringLiteral);\n    }\n    source.next();\n    setState(normal);\n    return \"error\";\n  }\n\n\n  var wellKnownWords = (function() {\n    var wkw = {};\n    function setType(t) {\n      return function () {\n        for (var i = 0; i < arguments.length; i++)\n          wkw[arguments[i]] = t;\n      };\n    }\n\n    setType(\"keyword\")(\n      \"case\", \"class\", \"data\", \"default\", \"deriving\", \"do\", \"else\", \"foreign\",\n      \"if\", \"import\", \"in\", \"infix\", \"infixl\", \"infixr\", \"instance\", \"let\",\n      \"module\", \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\");\n\n    setType(\"keyword\")(\n      \"\\.\\.\", \":\", \"::\", \"=\", \"\\\\\", \"<-\", \"->\", \"@\", \"~\", \"=>\");\n\n    setType(\"builtin\")(\n      \"!!\", \"$!\", \"$\", \"&&\", \"+\", \"++\", \"-\", \".\", \"/\", \"/=\", \"<\", \"<*\", \"<=\",\n      \"<$>\", \"<*>\", \"=<<\", \"==\", \">\", \">=\", \">>\", \">>=\", \"^\", \"^^\", \"||\", \"*\",\n      \"*>\", \"**\");\n\n    setType(\"builtin\")(\n      \"Applicative\", \"Bool\", \"Bounded\", \"Char\", \"Double\", \"EQ\", \"Either\", \"Enum\",\n      \"Eq\", \"False\", \"FilePath\", \"Float\", \"Floating\", \"Fractional\", \"Functor\",\n      \"GT\", \"IO\", \"IOError\", \"Int\", \"Integer\", \"Integral\", \"Just\", \"LT\", \"Left\",\n      \"Maybe\", \"Monad\", \"Nothing\", \"Num\", \"Ord\", \"Ordering\", \"Rational\", \"Read\",\n      \"ReadS\", \"Real\", \"RealFloat\", \"RealFrac\", \"Right\", \"Show\", \"ShowS\",\n      \"String\", \"True\");\n\n    setType(\"builtin\")(\n      \"abs\", \"acos\", \"acosh\", \"all\", \"and\", \"any\", \"appendFile\", \"asTypeOf\",\n      \"asin\", \"asinh\", \"atan\", \"atan2\", \"atanh\", \"break\", \"catch\", \"ceiling\",\n      \"compare\", \"concat\", \"concatMap\", \"const\", \"cos\", \"cosh\", \"curry\",\n      \"cycle\", \"decodeFloat\", \"div\", \"divMod\", \"drop\", \"dropWhile\", \"either\",\n      \"elem\", \"encodeFloat\", \"enumFrom\", \"enumFromThen\", \"enumFromThenTo\",\n      \"enumFromTo\", \"error\", \"even\", \"exp\", \"exponent\", \"fail\", \"filter\",\n      \"flip\", \"floatDigits\", \"floatRadix\", \"floatRange\", \"floor\", \"fmap\",\n      \"foldl\", \"foldl1\", \"foldr\", \"foldr1\", \"fromEnum\", \"fromInteger\",\n      \"fromIntegral\", \"fromRational\", \"fst\", \"gcd\", \"getChar\", \"getContents\",\n      \"getLine\", \"head\", \"id\", \"init\", \"interact\", \"ioError\", \"isDenormalized\",\n      \"isIEEE\", \"isInfinite\", \"isNaN\", \"isNegativeZero\", \"iterate\", \"last\",\n      \"lcm\", \"length\", \"lex\", \"lines\", \"log\", \"logBase\", \"lookup\", \"map\",\n      \"mapM\", \"mapM_\", \"max\", \"maxBound\", \"maximum\", \"maybe\", \"min\", \"minBound\",\n      \"minimum\", \"mod\", \"negate\", \"not\", \"notElem\", \"null\", \"odd\", \"or\",\n      \"otherwise\", \"pi\", \"pred\", \"print\", \"product\", \"properFraction\", \"pure\",\n      \"putChar\", \"putStr\", \"putStrLn\", \"quot\", \"quotRem\", \"read\", \"readFile\",\n      \"readIO\", \"readList\", \"readLn\", \"readParen\", \"reads\", \"readsPrec\",\n      \"realToFrac\", \"recip\", \"rem\", \"repeat\", \"replicate\", \"return\", \"reverse\",\n      \"round\", \"scaleFloat\", \"scanl\", \"scanl1\", \"scanr\", \"scanr1\", \"seq\",\n      \"sequence\", \"sequence_\", \"show\", \"showChar\", \"showList\", \"showParen\",\n      \"showString\", \"shows\", \"showsPrec\", \"significand\", \"signum\", \"sin\",\n      \"sinh\", \"snd\", \"span\", \"splitAt\", \"sqrt\", \"subtract\", \"succ\", \"sum\",\n      \"tail\", \"take\", \"takeWhile\", \"tan\", \"tanh\", \"toEnum\", \"toInteger\",\n      \"toRational\", \"truncate\", \"uncurry\", \"undefined\", \"unlines\", \"until\",\n      \"unwords\", \"unzip\", \"unzip3\", \"userError\", \"words\", \"writeFile\", \"zip\",\n      \"zip3\", \"zipWith\", \"zipWith3\");\n\n    var override = modeConfig.overrideKeywords;\n    if (override) for (var word in override) if (override.hasOwnProperty(word))\n      wkw[word] = override[word];\n\n    return wkw;\n  })();\n\n\n\n  return {\n    startState: function ()  { return { f: normal }; },\n    copyState:  function (s) { return { f: s.f }; },\n\n    token: function(stream, state) {\n      var t = state.f(stream, function(s) { state.f = s; });\n      var w = stream.current();\n      return wellKnownWords.hasOwnProperty(w) ? wellKnownWords[w] : t;\n    },\n\n    blockCommentStart: \"{-\",\n    blockCommentEnd: \"-}\",\n    lineComment: \"--\"\n  };\n\n});\n\nCodeMirror.defineMIME(\"text/x-haskell\", \"haskell\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\"]);\n  var commonKeywords = [\"as\", \"assert\", \"break\", \"class\", \"continue\",\n                        \"def\", \"del\", \"elif\", \"else\", \"except\", \"finally\",\n                        \"for\", \"from\", \"global\", \"if\", \"import\",\n                        \"lambda\", \"pass\", \"raise\", \"return\",\n                        \"try\", \"while\", \"with\", \"yield\", \"in\"];\n  var commonBuiltins = [\"abs\", \"all\", \"any\", \"bin\", \"bool\", \"bytearray\", \"callable\", \"chr\",\n                        \"classmethod\", \"compile\", \"complex\", \"delattr\", \"dict\", \"dir\", \"divmod\",\n                        \"enumerate\", \"eval\", \"filter\", \"float\", \"format\", \"frozenset\",\n                        \"getattr\", \"globals\", \"hasattr\", \"hash\", \"help\", \"hex\", \"id\",\n                        \"input\", \"int\", \"isinstance\", \"issubclass\", \"iter\", \"len\",\n                        \"list\", \"locals\", \"map\", \"max\", \"memoryview\", \"min\", \"next\",\n                        \"object\", \"oct\", \"open\", \"ord\", \"pow\", \"property\", \"range\",\n                        \"repr\", \"reversed\", \"round\", \"set\", \"setattr\", \"slice\",\n                        \"sorted\", \"staticmethod\", \"str\", \"sum\", \"super\", \"tuple\",\n                        \"type\", \"vars\", \"zip\", \"__import__\", \"NotImplemented\",\n                        \"Ellipsis\", \"__debug__\"];\n  CodeMirror.registerHelper(\"hintWords\", \"python\", commonKeywords.concat(commonBuiltins));\n\n  function top(state) {\n    return state.scopes[state.scopes.length - 1];\n  }\n\n  CodeMirror.defineMode(\"python\", function(conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    var delimiters = parserConf.delimiters || parserConf.singleDelimiters || /^[\\(\\)\\[\\]\\{\\}@,:`=;\\.\\\\]/;\n    //               (Backwards-compatiblity with old, cumbersome config system)\n    var operators = [parserConf.singleOperators, parserConf.doubleOperators, parserConf.doubleDelimiters, parserConf.tripleDelimiters,\n                     parserConf.operators || /^([-+*/%\\/&|^]=?|[<>=]+|\\/\\/=?|\\*\\*=?|!=|[~!@]|\\.\\.\\.)/]\n    for (var i = 0; i < operators.length; i++) if (!operators[i]) operators.splice(i--, 1)\n\n    var hangingIndent = parserConf.hangingIndent || conf.indentUnit;\n\n    var myKeywords = commonKeywords, myBuiltins = commonBuiltins;\n    if (parserConf.extra_keywords != undefined)\n      myKeywords = myKeywords.concat(parserConf.extra_keywords);\n\n    if (parserConf.extra_builtins != undefined)\n      myBuiltins = myBuiltins.concat(parserConf.extra_builtins);\n\n    var py3 = !(parserConf.version && Number(parserConf.version) < 3)\n    if (py3) {\n      // since http://legacy.python.org/dev/peps/pep-0465/ @ is also an operator\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z\\u00A1-\\uFFFF][_A-Za-z0-9\\u00A1-\\uFFFF]*/;\n      myKeywords = myKeywords.concat([\"nonlocal\", \"False\", \"True\", \"None\", \"async\", \"await\"]);\n      myBuiltins = myBuiltins.concat([\"ascii\", \"bytes\", \"exec\", \"print\"]);\n      var stringPrefixes = new RegExp(\"^(([rbuf]|(br)|(fr))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    } else {\n      var identifiers = parserConf.identifiers|| /^[_A-Za-z][_A-Za-z0-9]*/;\n      myKeywords = myKeywords.concat([\"exec\", \"print\"]);\n      myBuiltins = myBuiltins.concat([\"apply\", \"basestring\", \"buffer\", \"cmp\", \"coerce\", \"execfile\",\n                                      \"file\", \"intern\", \"long\", \"raw_input\", \"reduce\", \"reload\",\n                                      \"unichr\", \"unicode\", \"xrange\", \"False\", \"True\", \"None\"]);\n      var stringPrefixes = new RegExp(\"^(([rubf]|(ur)|(br))?('{3}|\\\"{3}|['\\\"]))\", \"i\");\n    }\n    var keywords = wordRegexp(myKeywords);\n    var builtins = wordRegexp(myBuiltins);\n\n    // tokenizers\n    function tokenBase(stream, state) {\n      var sol = stream.sol() && state.lastToken != \"\\\\\"\n      if (sol) state.indent = stream.indentation()\n      // Handle scope changes\n      if (sol && top(state).type == \"py\") {\n        var scopeOffset = top(state).offset;\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n          if (lineOffset > scopeOffset)\n            pushPyScope(state);\n          else if (lineOffset < scopeOffset && dedent(stream, state) && stream.peek() != \"#\")\n            state.errorToken = true;\n          return null;\n        } else {\n          var style = tokenBaseInner(stream, state);\n          if (scopeOffset > 0 && dedent(stream, state))\n            style += \" \" + ERRORCLASS;\n          return style;\n        }\n      }\n      return tokenBaseInner(stream, state);\n    }\n\n    function tokenBaseInner(stream, state) {\n      if (stream.eatSpace()) return null;\n\n      // Handle Comments\n      if (stream.match(/^#.*/)) return \"comment\";\n\n      // Handle Number Literals\n      if (stream.match(/^[0-9\\.]/, false)) {\n        var floatLiteral = false;\n        // Floats\n        if (stream.match(/^[\\d_]*\\.\\d+(e[\\+\\-]?\\d+)?/i)) { floatLiteral = true; }\n        if (stream.match(/^[\\d_]+\\.\\d*/)) { floatLiteral = true; }\n        if (stream.match(/^\\.\\d+/)) { floatLiteral = true; }\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return \"number\";\n        }\n        // Integers\n        var intLiteral = false;\n        // Hex\n        if (stream.match(/^0x[0-9a-f_]+/i)) intLiteral = true;\n        // Binary\n        if (stream.match(/^0b[01_]+/i)) intLiteral = true;\n        // Octal\n        if (stream.match(/^0o[0-7_]+/i)) intLiteral = true;\n        // Decimal\n        if (stream.match(/^[1-9][\\d_]*(e[\\+\\-]?[\\d_]+)?/)) {\n          // Decimal literals may be \"imaginary\"\n          stream.eat(/J/i);\n          // TODO - Can you have imaginary longs?\n          intLiteral = true;\n        }\n        // Zero by itself with no other piece of number.\n        if (stream.match(/^0(?![\\dx])/i)) intLiteral = true;\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return \"number\";\n        }\n      }\n\n      // Handle Strings\n      if (stream.match(stringPrefixes)) {\n        var isFmtString = stream.current().toLowerCase().indexOf('f') !== -1;\n        if (!isFmtString) {\n          state.tokenize = tokenStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        } else {\n          state.tokenize = formatStringFactory(stream.current(), state.tokenize);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      for (var i = 0; i < operators.length; i++)\n        if (stream.match(operators[i])) return \"operator\"\n\n      if (stream.match(delimiters)) return \"punctuation\";\n\n      if (state.lastToken == \".\" && stream.match(identifiers))\n        return \"property\";\n\n      if (stream.match(keywords) || stream.match(wordOperators))\n        return \"keyword\";\n\n      if (stream.match(builtins))\n        return \"builtin\";\n\n      if (stream.match(/^(self|cls)\\b/))\n        return \"variable-2\";\n\n      if (stream.match(identifiers)) {\n        if (state.lastToken == \"def\" || state.lastToken == \"class\")\n          return \"def\";\n        return \"variable\";\n      }\n\n      // Handle non-detected items\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function formatStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenNestedExpr(depth) {\n        return function(stream, state) {\n          var inner = tokenBaseInner(stream, state)\n          if (inner == \"punctuation\") {\n            if (stream.current() == \"{\") {\n              state.tokenize = tokenNestedExpr(depth + 1)\n            } else if (stream.current() == \"}\") {\n              if (depth > 1) state.tokenize = tokenNestedExpr(depth - 1)\n              else state.tokenize = tokenString\n            }\n          }\n          return inner\n        }\n      }\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\{\\}\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else if (stream.match('{{')) {\n            // ignore {{ in f-str\n            return OUTCLASS;\n          } else if (stream.match('{', false)) {\n            // switch to nested mode\n            state.tokenize = tokenNestedExpr(0)\n            if (stream.current()) return OUTCLASS;\n            else return state.tokenize(stream, state)\n          } else if (stream.match('}}')) {\n            return OUTCLASS;\n          } else if (stream.match('}')) {\n            // single } in f-string is an error\n            return ERRORCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function tokenStringFactory(delimiter, tokenOuter) {\n      while (\"rubf\".indexOf(delimiter.charAt(0).toLowerCase()) >= 0)\n        delimiter = delimiter.substr(1);\n\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = \"string\";\n\n      function tokenString(stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\\\]/);\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n            if (singleline && stream.eol())\n              return OUTCLASS;\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenOuter;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n        if (singleline) {\n          if (parserConf.singleLineStringErrors)\n            return ERRORCLASS;\n          else\n            state.tokenize = tokenOuter;\n        }\n        return OUTCLASS;\n      }\n      tokenString.isString = true;\n      return tokenString;\n    }\n\n    function pushPyScope(state) {\n      while (top(state).type != \"py\") state.scopes.pop()\n      state.scopes.push({offset: top(state).offset + conf.indentUnit,\n                         type: \"py\",\n                         align: null})\n    }\n\n    function pushBracketScope(stream, state, type) {\n      var align = stream.match(/^([\\s\\[\\{\\(]|#.*)*$/, false) ? null : stream.column() + 1\n      state.scopes.push({offset: state.indent + hangingIndent,\n                         type: type,\n                         align: align})\n    }\n\n    function dedent(stream, state) {\n      var indented = stream.indentation();\n      while (state.scopes.length > 1 && top(state).offset > indented) {\n        if (top(state).type != \"py\") return true;\n        state.scopes.pop();\n      }\n      return top(state).offset != indented;\n    }\n\n    function tokenLexer(stream, state) {\n      if (stream.sol()) state.beginningOfLine = true;\n\n      var style = state.tokenize(stream, state);\n      var current = stream.current();\n\n      // Handle decorators\n      if (state.beginningOfLine && current == \"@\")\n        return stream.match(identifiers, false) ? \"meta\" : py3 ? \"operator\" : ERRORCLASS;\n\n      if (/\\S/.test(current)) state.beginningOfLine = false;\n\n      if ((style == \"variable\" || style == \"builtin\")\n          && state.lastToken == \"meta\")\n        style = \"meta\";\n\n      // Handle scope changes.\n      if (current == \"pass\" || current == \"return\")\n        state.dedent += 1;\n\n      if (current == \"lambda\") state.lambda = true;\n      if (current == \":\" && !state.lambda && top(state).type == \"py\")\n        pushPyScope(state);\n\n      if (current.length == 1 && !/string|comment/.test(style)) {\n        var delimiter_index = \"[({\".indexOf(current);\n        if (delimiter_index != -1)\n          pushBracketScope(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n\n        delimiter_index = \"])}\".indexOf(current);\n        if (delimiter_index != -1) {\n          if (top(state).type == current) state.indent = state.scopes.pop().offset - hangingIndent\n          else return ERRORCLASS;\n        }\n      }\n      if (state.dedent > 0 && stream.eol() && top(state).type == \"py\") {\n        if (state.scopes.length > 1) state.scopes.pop();\n        state.dedent -= 1;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scopes: [{offset: basecolumn || 0, type: \"py\", align: null}],\n          indent: basecolumn || 0,\n          lastToken: null,\n          lambda: false,\n          dedent: 0\n        };\n      },\n\n      token: function(stream, state) {\n        var addErr = state.errorToken;\n        if (addErr) state.errorToken = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\")\n          state.lastToken = (style == \"keyword\" || style == \"punctuation\") ? stream.current() : style;\n        if (style == \"punctuation\") style = null;\n\n        if (stream.eol() && state.lambda)\n          state.lambda = false;\n        return addErr ? style + \" \" + ERRORCLASS : style;\n      },\n\n      indent: function(state, textAfter) {\n        if (state.tokenize != tokenBase)\n          return state.tokenize.isString ? CodeMirror.Pass : 0;\n\n        var scope = top(state), closing = scope.type == textAfter.charAt(0)\n        if (scope.align != null)\n          return scope.align - (closing ? 1 : 0)\n        else\n          return scope.offset - (closing ? hangingIndent : 0)\n      },\n\n      electricInput: /^\\s*[\\}\\]\\)]$/,\n      closeBrackets: {triples: \"'\\\"\"},\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  });\n\n  CodeMirror.defineMIME(\"text/x-python\", \"python\");\n\n  var words = function(str) { return str.split(\" \"); };\n\n  CodeMirror.defineMIME(\"text/x-cython\", {\n    name: \"python\",\n    extra_keywords: words(\"by cdef cimport cpdef ctypedef enum except \"+\n                          \"extern gil include nogil property public \"+\n                          \"readonly struct union DEF IF ELIF ELSE\")\n  });\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/simple\"), require(\"../../addon/mode/multiplex\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/simple\", \"../../addon/mode/multiplex\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode(\"handlebars-tags\", {\n    start: [\n      { regex: /\\{\\{\\{/, push: \"handlebars_raw\", token: \"tag\" },\n      { regex: /\\{\\{!--/, push: \"dash_comment\", token: \"comment\" },\n      { regex: /\\{\\{!/,   push: \"comment\", token: \"comment\" },\n      { regex: /\\{\\{/,    push: \"handlebars\", token: \"tag\" }\n    ],\n    handlebars_raw: [\n      { regex: /\\}\\}\\}/, pop: true, token: \"tag\" },\n    ],\n    handlebars: [\n      { regex: /\\}\\}/, pop: true, token: \"tag\" },\n\n      // Double and single quotes\n      { regex: /\"(?:[^\\\\\"]|\\\\.)*\"?/, token: \"string\" },\n      { regex: /'(?:[^\\\\']|\\\\.)*'?/, token: \"string\" },\n\n      // Handlebars keywords\n      { regex: />|[#\\/]([A-Za-z_]\\w*)/, token: \"keyword\" },\n      { regex: /(?:else|this)\\b/, token: \"keyword\" },\n\n      // Numeral\n      { regex: /\\d+/i, token: \"number\" },\n\n      // Atoms like = and .\n      { regex: /=|~|@|true|false/, token: \"atom\" },\n\n      // Paths\n      { regex: /(?:\\.\\.\\/)*(?:[A-Za-z_][\\w\\.]*)+/, token: \"variable-2\" }\n    ],\n    dash_comment: [\n      { regex: /--\\}\\}/, pop: true, token: \"comment\" },\n\n      // Commented code\n      { regex: /./, token: \"comment\"}\n    ],\n    comment: [\n      { regex: /\\}\\}/, pop: true, token: \"comment\" },\n      { regex: /./, token: \"comment\" }\n    ],\n    meta: {\n      blockCommentStart: \"{{--\",\n      blockCommentEnd: \"--}}\"\n    }\n  });\n\n  CodeMirror.defineMode(\"handlebars\", function(config, parserConfig) {\n    var handlebars = CodeMirror.getMode(config, \"handlebars-tags\");\n    if (!parserConfig || !parserConfig.base) return handlebars;\n    return CodeMirror.multiplexingMode(\n      CodeMirror.getMode(config, parserConfig.base),\n      {open: \"{{\", close: \"}}\", mode: handlebars, parseDelimiters: true}\n    );\n  });\n\n  CodeMirror.defineMIME(\"text/x-handlebars-template\", \"handlebars\");\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.multiplexingMode = function(outer /*, others */) {\n  // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\n  var others = Array.prototype.slice.call(arguments, 1);\n\n  function indexOf(string, pattern, from, returnEnd) {\n    if (typeof pattern == \"string\") {\n      var found = string.indexOf(pattern, from);\n      return returnEnd && found > -1 ? found + pattern.length : found;\n    }\n    var m = pattern.exec(from ? string.slice(from) : string);\n    return m ? m.index + from + (returnEnd ? m[0].length : 0) : -1;\n  }\n\n  return {\n    startState: function() {\n      return {\n        outer: CodeMirror.startState(outer),\n        innerActive: null,\n        inner: null\n      };\n    },\n\n    copyState: function(state) {\n      return {\n        outer: CodeMirror.copyState(outer, state.outer),\n        innerActive: state.innerActive,\n        inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)\n      };\n    },\n\n    token: function(stream, state) {\n      if (!state.innerActive) {\n        var cutOff = Infinity, oldContent = stream.string;\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          var found = indexOf(oldContent, other.open, stream.pos);\n          if (found == stream.pos) {\n            if (!other.parseDelimiters) stream.match(other.open);\n            state.innerActive = other;\n\n            // Get the outer indent, making sure to handle CodeMirror.Pass\n            var outerIndent = 0;\n            if (outer.indent) {\n              var possibleOuterIndent = outer.indent(state.outer, \"\", \"\");\n              if (possibleOuterIndent !== CodeMirror.Pass) outerIndent = possibleOuterIndent;\n            }\n\n            state.inner = CodeMirror.startState(other.mode, outerIndent);\n            return other.delimStyle && (other.delimStyle + \" \" + other.delimStyle + \"-open\");\n          } else if (found != -1 && found < cutOff) {\n            cutOff = found;\n          }\n        }\n        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\n        var outerToken = outer.token(stream, state.outer);\n        if (cutOff != Infinity) stream.string = oldContent;\n        return outerToken;\n      } else {\n        var curInner = state.innerActive, oldContent = stream.string;\n        if (!curInner.close && stream.sol()) {\n          state.innerActive = state.inner = null;\n          return this.token(stream, state);\n        }\n        var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos, curInner.parseDelimiters) : -1;\n        if (found == stream.pos && !curInner.parseDelimiters) {\n          stream.match(curInner.close);\n          state.innerActive = state.inner = null;\n          return curInner.delimStyle && (curInner.delimStyle + \" \" + curInner.delimStyle + \"-close\");\n        }\n        if (found > -1) stream.string = oldContent.slice(0, found);\n        var innerToken = curInner.mode.token(stream, state.inner);\n        if (found > -1) stream.string = oldContent;\n\n        if (found == stream.pos && curInner.parseDelimiters)\n          state.innerActive = state.inner = null;\n\n        if (curInner.innerStyle) {\n          if (innerToken) innerToken = innerToken + \" \" + curInner.innerStyle;\n          else innerToken = curInner.innerStyle;\n        }\n\n        return innerToken;\n      }\n    },\n\n    indent: function(state, textAfter, line) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (!mode.indent) return CodeMirror.Pass;\n      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter, line);\n    },\n\n    blankLine: function(state) {\n      var mode = state.innerActive ? state.innerActive.mode : outer;\n      if (mode.blankLine) {\n        mode.blankLine(state.innerActive ? state.inner : state.outer);\n      }\n      if (!state.innerActive) {\n        for (var i = 0; i < others.length; ++i) {\n          var other = others[i];\n          if (other.open === \"\\n\") {\n            state.innerActive = other;\n            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, \"\", \"\") : 0);\n          }\n        }\n      } else if (state.innerActive.close === \"\\n\") {\n        state.innerActive = state.inner = null;\n      }\n    },\n\n    electricChars: outer.electricChars,\n\n    innerMode: function(state) {\n      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};\n    }\n  };\n};\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../css/css\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../css/css\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"sass\", function(config) {\n  var cssMode = CodeMirror.mimeModes[\"text/css\"];\n  var propertyKeywords = cssMode.propertyKeywords || {},\n      colorKeywords = cssMode.colorKeywords || {},\n      valueKeywords = cssMode.valueKeywords || {},\n      fontProperties = cssMode.fontProperties || {};\n\n  function tokenRegexp(words) {\n    return new RegExp(\"^\" + words.join(\"|\"));\n  }\n\n  var keywords = [\"true\", \"false\", \"null\", \"auto\"];\n  var keywordsRegexp = new RegExp(\"^\" + keywords.join(\"|\"));\n\n  var operators = [\"\\\\(\", \"\\\\)\", \"=\", \">\", \"<\", \"==\", \">=\", \"<=\", \"\\\\+\", \"-\",\n                   \"\\\\!=\", \"/\", \"\\\\*\", \"%\", \"and\", \"or\", \"not\", \";\",\"\\\\{\",\"\\\\}\",\":\"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[a-zA-Z_][\\w\\-]*/;\n\n  var word;\n\n  function isEndLine(stream) {\n    return !stream.peek() || stream.match(/\\s+$/, false);\n  }\n\n  function urlTokens(stream, state) {\n    var ch = stream.peek();\n\n    if (ch === \")\") {\n      stream.next();\n      state.tokenizer = tokenBase;\n      return \"operator\";\n    } else if (ch === \"(\") {\n      stream.next();\n      stream.eatSpace();\n\n      return \"operator\";\n    } else if (ch === \"'\" || ch === '\"') {\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return \"string\";\n    } else {\n      state.tokenizer = buildStringTokenizer(\")\", false);\n      return \"string\";\n    }\n  }\n  function comment(indentation, multiLine) {\n    return function(stream, state) {\n      if (stream.sol() && stream.indentation() <= indentation) {\n        state.tokenizer = tokenBase;\n        return tokenBase(stream, state);\n      }\n\n      if (multiLine && stream.skipTo(\"*/\")) {\n        stream.next();\n        stream.next();\n        state.tokenizer = tokenBase;\n      } else {\n        stream.skipToEnd();\n      }\n\n      return \"comment\";\n    };\n  }\n\n  function buildStringTokenizer(quote, greedy) {\n    if (greedy == null) { greedy = true; }\n\n    function stringTokenizer(stream, state) {\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== \"\\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== \"\\\\\"));\n\n      if (endingString) {\n        if (nextChar !== quote && greedy) { stream.next(); }\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        state.tokenizer = tokenBase;\n        return \"string\";\n      } else if (nextChar === \"#\" && peekChar === \"{\") {\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return \"operator\";\n      } else {\n        return \"string\";\n      }\n    }\n\n    return stringTokenizer;\n  }\n\n  function buildInterpolationTokenizer(currentTokenizer) {\n    return function(stream, state) {\n      if (stream.peek() === \"}\") {\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return \"operator\";\n      } else {\n        return tokenBase(stream, state);\n      }\n    };\n  }\n\n  function indent(state) {\n    if (state.indentCount == 0) {\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  }\n\n  function dedent(state) {\n    if (state.scopes.length == 1) return;\n\n    state.scopes.shift();\n  }\n\n  function tokenBase(stream, state) {\n    var ch = stream.peek();\n\n    // Comment\n    if (stream.match(\"/*\")) {\n      state.tokenizer = comment(stream.indentation(), true);\n      return state.tokenizer(stream, state);\n    }\n    if (stream.match(\"//\")) {\n      state.tokenizer = comment(stream.indentation(), false);\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match(\"#{\")) {\n      state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return \"operator\";\n    }\n\n    // Strings\n    if (ch === '\"' || ch === \"'\") {\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return \"string\";\n    }\n\n    if(!state.cursorHalf){// state.cursorHalf === 0\n    // first half i.e. before : for key-value pairs\n    // including selectors\n\n      if (ch === \"-\") {\n        if (stream.match(/^-\\w+-/)) {\n          return \"meta\";\n        }\n      }\n\n      if (ch === \".\") {\n        stream.next();\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"qualifier\";\n        } else if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if (ch === \"#\") {\n        stream.next();\n        // ID selectors\n        if (stream.match(/^[\\w-]+/)) {\n          indent(state);\n          return \"builtin\";\n        }\n        if (stream.peek() === \"#\") {\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"variable-2\";\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/))\n        return \"number\";\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/))\n        return \"unit\";\n\n      if (stream.match(keywordsRegexp))\n        return \"keyword\";\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        return \"atom\";\n      }\n\n      if (ch === \"=\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^=[\\w-]+/)) {\n          indent(state);\n          return \"meta\";\n        }\n      }\n\n      if (ch === \"+\") {\n        // Match shortcut mixin definition\n        if (stream.match(/^\\+[\\w-]+/)){\n          return \"variable-3\";\n        }\n      }\n\n      if(ch === \"@\"){\n        if(stream.match(/@extend/)){\n          if(!stream.match(/\\s*[\\w]/))\n            dedent(state);\n        }\n      }\n\n\n      // Indent Directives\n      if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) {\n        indent(state);\n        return \"def\";\n      }\n\n      // Other Directives\n      if (ch === \"@\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        return \"def\";\n      }\n\n      if (stream.eatWhile(/[\\w-]/)){\n        if(stream.match(/ *: *[\\w-\\+\\$#!\\(\"']/,false)){\n          word = stream.current().toLowerCase();\n          var prop = state.prevProp + \"-\" + word;\n          if (propertyKeywords.hasOwnProperty(prop)) {\n            return \"property\";\n          } else if (propertyKeywords.hasOwnProperty(word)) {\n            state.prevProp = word;\n            return \"property\";\n          } else if (fontProperties.hasOwnProperty(word)) {\n            return \"property\";\n          }\n          return \"tag\";\n        }\n        else if(stream.match(/ *:/,false)){\n          indent(state);\n          state.cursorHalf = 1;\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        }\n        else if(stream.match(/ *,/,false)){\n          return \"tag\";\n        }\n        else{\n          indent(state);\n          return \"tag\";\n        }\n      }\n\n      if(ch === \":\"){\n        if (stream.match(pseudoElementsRegexp)){ // could be a pseudo-element\n          return \"variable-3\";\n        }\n        stream.next();\n        state.cursorHalf=1;\n        return \"operator\";\n      }\n\n    } // cursorHalf===0 ends here\n    else{\n\n      if (ch === \"#\") {\n        stream.next();\n        // Hex numbers\n        if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n          if (isEndLine(stream)) {\n            state.cursorHalf = 0;\n          }\n          return \"number\";\n        }\n      }\n\n      // Numbers\n      if (stream.match(/^-?[0-9\\.]+/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"number\";\n      }\n\n      // Units\n      if (stream.match(/^(px|em|in)\\b/)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"unit\";\n      }\n\n      if (stream.match(keywordsRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"keyword\";\n      }\n\n      if (stream.match(/^url/) && stream.peek() === \"(\") {\n        state.tokenizer = urlTokens;\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"atom\";\n      }\n\n      // Variables\n      if (ch === \"$\") {\n        stream.next();\n        stream.eatWhile(/[\\w-]/);\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"variable-2\";\n      }\n\n      // bang character for !important, !default, etc.\n      if (ch === \"!\") {\n        stream.next();\n        state.cursorHalf = 0;\n        return stream.match(/^[\\w]+/) ? \"keyword\": \"operator\";\n      }\n\n      if (stream.match(opRegexp)){\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        return \"operator\";\n      }\n\n      // attributes\n      if (stream.eatWhile(/[\\w-]/)) {\n        if (isEndLine(stream)) {\n          state.cursorHalf = 0;\n        }\n        word = stream.current().toLowerCase();\n        if (valueKeywords.hasOwnProperty(word)) {\n          return \"atom\";\n        } else if (colorKeywords.hasOwnProperty(word)) {\n          return \"keyword\";\n        } else if (propertyKeywords.hasOwnProperty(word)) {\n          state.prevProp = stream.current().toLowerCase();\n          return \"property\";\n        } else {\n          return \"tag\";\n        }\n      }\n\n      //stream.eatSpace();\n      if (isEndLine(stream)) {\n        state.cursorHalf = 0;\n        return null;\n      }\n\n    } // else ends here\n\n    if (stream.match(opRegexp))\n      return \"operator\";\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  }\n\n  function tokenLexer(stream, state) {\n    if (stream.sol()) state.indentCount = 0;\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === \"@return\" || current === \"}\"){\n      dedent(state);\n    }\n\n    if (style !== null) {\n      var startOfToken = stream.pos - current.length;\n\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++) {\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent)\n          newScopes.push(scope);\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  }\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: \"sass\"}],\n        indentCount: 0,\n        cursorHalf: 0,  // cursor half tells us if cursor lies after (1)\n                        // or before (0) colon (well... more or less)\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n}, \"css\");\n\nCodeMirror.defineMIME(\"text/x-sass\", \"sass\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode = function(name, states) {\n    CodeMirror.defineMode(name, function(config) {\n      return CodeMirror.simpleMode(config, states);\n    });\n  };\n\n  CodeMirror.simpleMode = function(config, states) {\n    ensureState(states, \"start\");\n    var states_ = {}, meta = states.meta || {}, hasIndentation = false;\n    for (var state in states) if (state != meta && states.hasOwnProperty(state)) {\n      var list = states_[state] = [], orig = states[state];\n      for (var i = 0; i < orig.length; i++) {\n        var data = orig[i];\n        list.push(new Rule(data, states));\n        if (data.indent || data.dedent) hasIndentation = true;\n      }\n    }\n    var mode = {\n      startState: function() {\n        return {state: \"start\", pending: null,\n                local: null, localState: null,\n                indent: hasIndentation ? [] : null};\n      },\n      copyState: function(state) {\n        var s = {state: state.state, pending: state.pending,\n                 local: state.local, localState: null,\n                 indent: state.indent && state.indent.slice(0)};\n        if (state.localState)\n          s.localState = CodeMirror.copyState(state.local.mode, state.localState);\n        if (state.stack)\n          s.stack = state.stack.slice(0);\n        for (var pers = state.persistentStates; pers; pers = pers.next)\n          s.persistentStates = {mode: pers.mode,\n                                spec: pers.spec,\n                                state: pers.state == state.localState ? s.localState : CodeMirror.copyState(pers.mode, pers.state),\n                                next: s.persistentStates};\n        return s;\n      },\n      token: tokenFunction(states_, config),\n      innerMode: function(state) { return state.local && {mode: state.local.mode, state: state.localState}; },\n      indent: indentFunction(states_, meta)\n    };\n    if (meta) for (var prop in meta) if (meta.hasOwnProperty(prop))\n      mode[prop] = meta[prop];\n    return mode;\n  };\n\n  function ensureState(states, name) {\n    if (!states.hasOwnProperty(name))\n      throw new Error(\"Undefined state \" + name + \" in simple mode\");\n  }\n\n  function toRegex(val, caret) {\n    if (!val) return /(?:)/;\n    var flags = \"\";\n    if (val instanceof RegExp) {\n      if (val.ignoreCase) flags = \"i\";\n      val = val.source;\n    } else {\n      val = String(val);\n    }\n    return new RegExp((caret === false ? \"\" : \"^\") + \"(?:\" + val + \")\", flags);\n  }\n\n  function asToken(val) {\n    if (!val) return null;\n    if (val.apply) return val\n    if (typeof val == \"string\") return val.replace(/\\./g, \" \");\n    var result = [];\n    for (var i = 0; i < val.length; i++)\n      result.push(val[i] && val[i].replace(/\\./g, \" \"));\n    return result;\n  }\n\n  function Rule(data, states) {\n    if (data.next || data.push) ensureState(states, data.next || data.push);\n    this.regex = toRegex(data.regex);\n    this.token = asToken(data.token);\n    this.data = data;\n  }\n\n  function tokenFunction(states, config) {\n    return function(stream, state) {\n      if (state.pending) {\n        var pend = state.pending.shift();\n        if (state.pending.length == 0) state.pending = null;\n        stream.pos += pend.text.length;\n        return pend.token;\n      }\n\n      if (state.local) {\n        if (state.local.end && stream.match(state.local.end)) {\n          var tok = state.local.endToken || null;\n          state.local = state.localState = null;\n          return tok;\n        } else {\n          var tok = state.local.mode.token(stream, state.localState), m;\n          if (state.local.endScan && (m = state.local.endScan.exec(stream.current())))\n            stream.pos = stream.start + m.index;\n          return tok;\n        }\n      }\n\n      var curState = states[state.state];\n      for (var i = 0; i < curState.length; i++) {\n        var rule = curState[i];\n        var matches = (!rule.data.sol || stream.sol()) && stream.match(rule.regex);\n        if (matches) {\n          if (rule.data.next) {\n            state.state = rule.data.next;\n          } else if (rule.data.push) {\n            (state.stack || (state.stack = [])).push(state.state);\n            state.state = rule.data.push;\n          } else if (rule.data.pop && state.stack && state.stack.length) {\n            state.state = state.stack.pop();\n          }\n\n          if (rule.data.mode)\n            enterLocalMode(config, state, rule.data.mode, rule.token);\n          if (rule.data.indent)\n            state.indent.push(stream.indentation() + config.indentUnit);\n          if (rule.data.dedent)\n            state.indent.pop();\n          var token = rule.token\n          if (token && token.apply) token = token(matches)\n          if (matches.length > 2 && rule.token && typeof rule.token != \"string\") {\n            state.pending = [];\n            for (var j = 2; j < matches.length; j++)\n              if (matches[j])\n                state.pending.push({text: matches[j], token: rule.token[j - 1]});\n            stream.backUp(matches[0].length - (matches[1] ? matches[1].length : 0));\n            return token[0];\n          } else if (token && token.join) {\n            return token[0];\n          } else {\n            return token;\n          }\n        }\n      }\n      stream.next();\n      return null;\n    };\n  }\n\n  function cmp(a, b) {\n    if (a === b) return true;\n    if (!a || typeof a != \"object\" || !b || typeof b != \"object\") return false;\n    var props = 0;\n    for (var prop in a) if (a.hasOwnProperty(prop)) {\n      if (!b.hasOwnProperty(prop) || !cmp(a[prop], b[prop])) return false;\n      props++;\n    }\n    for (var prop in b) if (b.hasOwnProperty(prop)) props--;\n    return props == 0;\n  }\n\n  function enterLocalMode(config, state, spec, token) {\n    var pers;\n    if (spec.persistent) for (var p = state.persistentStates; p && !pers; p = p.next)\n      if (spec.spec ? cmp(spec.spec, p.spec) : spec.mode == p.mode) pers = p;\n    var mode = pers ? pers.mode : spec.mode || CodeMirror.getMode(config, spec.spec);\n    var lState = pers ? pers.state : CodeMirror.startState(mode);\n    if (spec.persistent && !pers)\n      state.persistentStates = {mode: mode, spec: spec.spec, state: lState, next: state.persistentStates};\n\n    state.localState = lState;\n    state.local = {mode: mode,\n                   end: spec.end && toRegex(spec.end),\n                   endScan: spec.end && spec.forceEnd !== false && toRegex(spec.end, false),\n                   endToken: token && token.join ? token[token.length - 1] : token};\n  }\n\n  function indexOf(val, arr) {\n    for (var i = 0; i < arr.length; i++) if (arr[i] === val) return true;\n  }\n\n  function indentFunction(states, meta) {\n    return function(state, textAfter, line) {\n      if (state.local && state.local.mode.indent)\n        return state.local.mode.indent(state.localState, textAfter, line);\n      if (state.indent == null || state.local || meta.dontIndentStates && indexOf(state.state, meta.dontIndentStates) > -1)\n        return CodeMirror.Pass;\n\n      var pos = state.indent.length - 1, rules = states[state.state];\n      scan: for (;;) {\n        for (var i = 0; i < rules.length; i++) {\n          var rule = rules[i];\n          if (rule.data.dedent && rule.data.dedentIfLineStart !== false) {\n            var m = rule.regex.exec(textAfter);\n            if (m && m[0]) {\n              pos--;\n              if (rule.next || rule.push) rules = states[rule.next || rule.push];\n              textAfter = textAfter.slice(m[0].length);\n              continue scan;\n            }\n          }\n        }\n        break;\n      }\n      return pos < 0 ? 0 : state.indent[pos];\n    };\n  }\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"ruby\", function(config) {\n  function wordObj(words) {\n    var o = {};\n    for (var i = 0, e = words.length; i < e; ++i) o[words[i]] = true;\n    return o;\n  }\n  var keywords = wordObj([\n    \"alias\", \"and\", \"BEGIN\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"defined?\", \"do\", \"else\",\n    \"elsif\", \"END\", \"end\", \"ensure\", \"false\", \"for\", \"if\", \"in\", \"module\", \"next\", \"not\", \"or\",\n    \"redo\", \"rescue\", \"retry\", \"return\", \"self\", \"super\", \"then\", \"true\", \"undef\", \"unless\",\n    \"until\", \"when\", \"while\", \"yield\", \"nil\", \"raise\", \"throw\", \"catch\", \"fail\", \"loop\", \"callcc\",\n    \"caller\", \"lambda\", \"proc\", \"public\", \"protected\", \"private\", \"require\", \"load\",\n    \"require_relative\", \"extend\", \"autoload\", \"__END__\", \"__FILE__\", \"__LINE__\", \"__dir__\"\n  ]);\n  var indentWords = wordObj([\"def\", \"class\", \"case\", \"for\", \"while\", \"until\", \"module\", \"then\",\n                             \"catch\", \"loop\", \"proc\", \"begin\"]);\n  var dedentWords = wordObj([\"end\", \"until\"]);\n  var opening = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\"};\n  var closing = {\"]\": \"[\", \"}\": \"{\", \")\": \"(\"};\n  var curPunc;\n\n  function chain(newtok, stream, state) {\n    state.tokenize.push(newtok);\n    return newtok(stream, state);\n  }\n\n  function tokenBase(stream, state) {\n    if (stream.sol() && stream.match(\"=begin\") && stream.eol()) {\n      state.tokenize.push(readBlockComment);\n      return \"comment\";\n    }\n    if (stream.eatSpace()) return null;\n    var ch = stream.next(), m;\n    if (ch == \"`\" || ch == \"'\" || ch == '\"') {\n      return chain(readQuoted(ch, \"string\", ch == '\"' || ch == \"`\"), stream, state);\n    } else if (ch == \"/\") {\n      if (regexpAhead(stream))\n        return chain(readQuoted(ch, \"string-2\", true), stream, state);\n      else\n        return \"operator\";\n    } else if (ch == \"%\") {\n      var style = \"string\", embed = true;\n      if (stream.eat(\"s\")) style = \"atom\";\n      else if (stream.eat(/[WQ]/)) style = \"string\";\n      else if (stream.eat(/[r]/)) style = \"string-2\";\n      else if (stream.eat(/[wxq]/)) { style = \"string\"; embed = false; }\n      var delim = stream.eat(/[^\\w\\s=]/);\n      if (!delim) return \"operator\";\n      if (opening.propertyIsEnumerable(delim)) delim = opening[delim];\n      return chain(readQuoted(delim, style, embed, true), stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    } else if (ch == \"<\" && (m = stream.match(/^<([-~])[\\`\\\"\\']?([a-zA-Z_?]\\w*)[\\`\\\"\\']?(?:;|$)/))) {\n      return chain(readHereDoc(m[2], m[1]), stream, state);\n    } else if (ch == \"0\") {\n      if (stream.eat(\"x\")) stream.eatWhile(/[\\da-fA-F]/);\n      else if (stream.eat(\"b\")) stream.eatWhile(/[01]/);\n      else stream.eatWhile(/[0-7]/);\n      return \"number\";\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^[\\d_]*(?:\\.[\\d_]+)?(?:[eE][+\\-]?[\\d_]+)?/);\n      return \"number\";\n    } else if (ch == \"?\") {\n      while (stream.match(/^\\\\[CM]-/)) {}\n      if (stream.eat(\"\\\\\")) stream.eatWhile(/\\w/);\n      else stream.next();\n      return \"string\";\n    } else if (ch == \":\") {\n      if (stream.eat(\"'\")) return chain(readQuoted(\"'\", \"atom\", false), stream, state);\n      if (stream.eat('\"')) return chain(readQuoted('\"', \"atom\", true), stream, state);\n\n      // :> :>> :< :<< are valid symbols\n      if (stream.eat(/[\\<\\>]/)) {\n        stream.eat(/[\\<\\>]/);\n        return \"atom\";\n      }\n\n      // :+ :- :/ :* :| :& :! are valid symbols\n      if (stream.eat(/[\\+\\-\\*\\/\\&\\|\\:\\!]/)) {\n        return \"atom\";\n      }\n\n      // Symbols can't start by a digit\n      if (stream.eat(/[a-zA-Z$@_\\xa1-\\uffff]/)) {\n        stream.eatWhile(/[\\w$\\xa1-\\uffff]/);\n        // Only one ? ! = is allowed and only as the last character\n        stream.eat(/[\\?\\!\\=]/);\n        return \"atom\";\n      }\n      return \"operator\";\n    } else if (ch == \"@\" && stream.match(/^@?[a-zA-Z_\\xa1-\\uffff]/)) {\n      stream.eat(\"@\");\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      return \"variable-2\";\n    } else if (ch == \"$\") {\n      if (stream.eat(/[a-zA-Z_]/)) {\n        stream.eatWhile(/[\\w]/);\n      } else if (stream.eat(/\\d/)) {\n        stream.eat(/\\d/);\n      } else {\n        stream.next(); // Must be a special global like $: or $!\n      }\n      return \"variable-3\";\n    } else if (/[a-zA-Z_\\xa1-\\uffff]/.test(ch)) {\n      stream.eatWhile(/[\\w\\xa1-\\uffff]/);\n      stream.eat(/[\\?\\!]/);\n      if (stream.eat(\":\")) return \"atom\";\n      return \"ident\";\n    } else if (ch == \"|\" && (state.varList || state.lastTok == \"{\" || state.lastTok == \"do\")) {\n      curPunc = \"|\";\n      return null;\n    } else if (/[\\(\\)\\[\\]{}\\\\;]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    } else if (ch == \"-\" && stream.eat(\">\")) {\n      return \"arrow\";\n    } else if (/[=+\\-\\/*:\\.^%<>~|]/.test(ch)) {\n      var more = stream.eatWhile(/[=+\\-\\/*:\\.^%<>~|]/);\n      if (ch == \".\" && !more) curPunc = \".\";\n      return \"operator\";\n    } else {\n      return null;\n    }\n  }\n\n  function regexpAhead(stream) {\n    var start = stream.pos, depth = 0, next, found = false, escaped = false\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (\"[{(\".indexOf(next) > -1) {\n          depth++\n        } else if (\"]})\".indexOf(next) > -1) {\n          depth--\n          if (depth < 0) break\n        } else if (next == \"/\" && depth == 0) {\n          found = true\n          break\n        }\n        escaped = next == \"\\\\\"\n      } else {\n        escaped = false\n      }\n    }\n    stream.backUp(stream.pos - start)\n    return found\n  }\n\n  function tokenBaseUntilBrace(depth) {\n    if (!depth) depth = 1;\n    return function(stream, state) {\n      if (stream.peek() == \"}\") {\n        if (depth == 1) {\n          state.tokenize.pop();\n          return state.tokenize[state.tokenize.length-1](stream, state);\n        } else {\n          state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1);\n        }\n      } else if (stream.peek() == \"{\") {\n        state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1);\n      }\n      return tokenBase(stream, state);\n    };\n  }\n  function tokenBaseOnce() {\n    var alreadyCalled = false;\n    return function(stream, state) {\n      if (alreadyCalled) {\n        state.tokenize.pop();\n        return state.tokenize[state.tokenize.length-1](stream, state);\n      }\n      alreadyCalled = true;\n      return tokenBase(stream, state);\n    };\n  }\n  function readQuoted(quote, style, embed, unescaped) {\n    return function(stream, state) {\n      var escaped = false, ch;\n\n      if (state.context.type === 'read-quoted-paused') {\n        state.context = state.context.prev;\n        stream.eat(\"}\");\n      }\n\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && (unescaped || !escaped)) {\n          state.tokenize.pop();\n          break;\n        }\n        if (embed && ch == \"#\" && !escaped) {\n          if (stream.eat(\"{\")) {\n            if (quote == \"}\") {\n              state.context = {prev: state.context, type: 'read-quoted-paused'};\n            }\n            state.tokenize.push(tokenBaseUntilBrace());\n            break;\n          } else if (/[@\\$]/.test(stream.peek())) {\n            state.tokenize.push(tokenBaseOnce());\n            break;\n          }\n        }\n        escaped = !escaped && ch == \"\\\\\";\n      }\n      return style;\n    };\n  }\n  function readHereDoc(phrase, mayIndent) {\n    return function(stream, state) {\n      if (mayIndent) stream.eatSpace()\n      if (stream.match(phrase)) state.tokenize.pop();\n      else stream.skipToEnd();\n      return \"string\";\n    };\n  }\n  function readBlockComment(stream, state) {\n    if (stream.sol() && stream.match(\"=end\") && stream.eol())\n      state.tokenize.pop();\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: [tokenBase],\n              indented: 0,\n              context: {type: \"top\", indented: -config.indentUnit},\n              continuedLine: false,\n              lastTok: null,\n              varList: false};\n    },\n\n    token: function(stream, state) {\n      curPunc = null;\n      if (stream.sol()) state.indented = stream.indentation();\n      var style = state.tokenize[state.tokenize.length-1](stream, state), kwtype;\n      var thisTok = curPunc;\n      if (style == \"ident\") {\n        var word = stream.current();\n        style = state.lastTok == \".\" ? \"property\"\n          : keywords.propertyIsEnumerable(stream.current()) ? \"keyword\"\n          : /^[A-Z]/.test(word) ? \"tag\"\n          : (state.lastTok == \"def\" || state.lastTok == \"class\" || state.varList) ? \"def\"\n          : \"variable\";\n        if (style == \"keyword\") {\n          thisTok = word;\n          if (indentWords.propertyIsEnumerable(word)) kwtype = \"indent\";\n          else if (dedentWords.propertyIsEnumerable(word)) kwtype = \"dedent\";\n          else if ((word == \"if\" || word == \"unless\") && stream.column() == stream.indentation())\n            kwtype = \"indent\";\n          else if (word == \"do\" && state.context.indented < state.indented)\n            kwtype = \"indent\";\n        }\n      }\n      if (curPunc || (style && style != \"comment\")) state.lastTok = thisTok;\n      if (curPunc == \"|\") state.varList = !state.varList;\n\n      if (kwtype == \"indent\" || /[\\(\\[\\{]/.test(curPunc))\n        state.context = {prev: state.context, type: curPunc || style, indented: state.indented};\n      else if ((kwtype == \"dedent\" || /[\\)\\]\\}]/.test(curPunc)) && state.context.prev)\n        state.context = state.context.prev;\n\n      if (stream.eol())\n        state.continuedLine = (curPunc == \"\\\\\" || style == \"operator\");\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize[state.tokenize.length-1] != tokenBase) return CodeMirror.Pass;\n      var firstChar = textAfter && textAfter.charAt(0);\n      var ct = state.context;\n      var closed = ct.type == closing[firstChar] ||\n        ct.type == \"keyword\" && /^(?:end|until|else|elsif|when|rescue)\\b/.test(textAfter);\n      return ct.indented + (closed ? 0 : config.indentUnit) +\n        (state.continuedLine ? config.indentUnit : 0);\n    },\n\n    electricInput: /^\\s*(?:end|rescue|elsif|else|\\})$/,\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-ruby\", \"ruby\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Utility function that allows modes to be combined. The mode given\n// as the base argument takes care of most of the normal mode\n// functionality, but a second (typically simple) mode is used, which\n// can override the style of text. Both modes get to parse all of the\n// text, but when both assign a non-null style to a piece of code, the\n// overlay wins, unless the combine argument was true and not overridden,\n// or state.overlay.combineTokens was true, in which case the styles are\n// combined.\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.overlayMode = function(base, overlay, combine) {\n  return {\n    startState: function() {\n      return {\n        base: CodeMirror.startState(base),\n        overlay: CodeMirror.startState(overlay),\n        basePos: 0, baseCur: null,\n        overlayPos: 0, overlayCur: null,\n        streamSeen: null\n      };\n    },\n    copyState: function(state) {\n      return {\n        base: CodeMirror.copyState(base, state.base),\n        overlay: CodeMirror.copyState(overlay, state.overlay),\n        basePos: state.basePos, baseCur: null,\n        overlayPos: state.overlayPos, overlayCur: null\n      };\n    },\n\n    token: function(stream, state) {\n      if (stream != state.streamSeen ||\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\n        state.streamSeen = stream;\n        state.basePos = state.overlayPos = stream.start;\n      }\n\n      if (stream.start == state.basePos) {\n        state.baseCur = base.token(stream, state.base);\n        state.basePos = stream.pos;\n      }\n      if (stream.start == state.overlayPos) {\n        stream.pos = stream.start;\n        state.overlayCur = overlay.token(stream, state.overlay);\n        state.overlayPos = stream.pos;\n      }\n      stream.pos = Math.min(state.basePos, state.overlayPos);\n\n      // state.overlay.combineTokens always takes precedence over combine,\n      // unless set to null\n      if (state.overlayCur == null) return state.baseCur;\n      else if (state.baseCur != null &&\n               state.overlay.combineTokens ||\n               combine && state.overlay.combineTokens == null)\n        return state.baseCur + \" \" + state.overlayCur;\n      else return state.overlayCur;\n    },\n\n    indent: base.indent && function(state, textAfter, line) {\n      return base.indent(state.base, textAfter, line);\n    },\n    electricChars: base.electricChars,\n\n    innerMode: function(state) { return {state: state.base, mode: base}; },\n\n    blankLine: function(state) {\n      var baseToken, overlayToken;\n      if (base.blankLine) baseToken = base.blankLine(state.base);\n      if (overlay.blankLine) overlayToken = overlay.blankLine(state.overlay);\n\n      return overlayToken == null ?\n        baseToken :\n        (combine && baseToken != null ? baseToken + \" \" + overlayToken : overlayToken);\n    }\n  };\n};\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"coffeescript\", function(conf, parserConf) {\n  var ERRORCLASS = \"error\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                  \"is\", \"isnt\", \"in\",\n                                  \"instanceof\", \"typeof\"]);\n  var indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                        \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\n  var commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                        \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                        \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n          return \"indent\";\n        } else if (lineOffset < scopeOffset) {\n          return \"dedent\";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match(\"####\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle multi line comments\n    if (stream.match(\"###\")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == \".\"){\n          stream.backUp(1);\n        }\n        return \"number\";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return \"number\";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, \"string\");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, \"string-2\");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return \"operator\";\n    }\n    if (stream.match(delimiters)) {\n      return \"punctuation\";\n    }\n\n    if (stream.match(constants)) {\n      return \"atom\";\n    }\n\n    if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n      return \"property\";\n    }\n\n    if (stream.match(keywords)) {\n      return \"keyword\";\n    }\n\n    if (stream.match(identifiers)) {\n      return \"variable\";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\/\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['\"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match(\"###\")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile(\"#\");\n    }\n    return \"comment\";\n  }\n\n  function indent(stream, state, type) {\n    type = type || \"coffee\";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === \"coffee\" || scope.type == \"}\") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== \"coffee\") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === \"coffee\") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle scope changes.\n    if (current === \"return\") {\n      state.dedent = true;\n    }\n    if (((current === \"->\" || current === \"=>\") && stream.eol())\n        || style === \"indent\") {\n      indent(stream, state);\n    }\n    var delimiter_index = \"[({\".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == \"then\"){\n      dedent(stream, state);\n    }\n\n\n    if (style === \"dedent\") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = \"])}\".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent && stream.eol()) {\n      if (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      state.dedent = false;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:\"coffee\", prev: null, align: false},\n        prop: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (style && style != \"comment\") {\n        if (fillAlign) fillAlign.align = true;\n        state.prop = style == \"punctuation\" && stream.current() == \".\"\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n  return external;\n});\n\n// IANA registered media type\n// https://www.iana.org/assignments/media-types/\nCodeMirror.defineMIME(\"application/vnd.coffeescript\", \"coffeescript\");\n\nCodeMirror.defineMIME(\"text/x-coffeescript\", \"coffeescript\");\nCodeMirror.defineMIME(\"text/coffeescript\", \"coffeescript\");\n\n});\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"yaml\", function() {\n\n  var cons = ['true', 'false', 'on', 'off', 'yes', 'no'];\n  var keywordRegex = new RegExp(\"\\\\b((\"+cons.join(\")|(\")+\"))$\", 'i');\n\n  return {\n    token: function(stream, state) {\n      var ch = stream.peek();\n      var esc = state.escaped;\n      state.escaped = false;\n      /* comments */\n      if (ch == \"#\" && (stream.pos == 0 || /\\s/.test(stream.string.charAt(stream.pos - 1)))) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.match(/^('([^']|\\\\.)*'?|\"([^\"]|\\\\.)*\"?)/))\n        return \"string\";\n\n      if (state.literal && stream.indentation() > state.keyCol) {\n        stream.skipToEnd(); return \"string\";\n      } else if (state.literal) { state.literal = false; }\n      if (stream.sol()) {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        /* document start */\n        if(stream.match(/---/)) { return \"def\"; }\n        /* document end */\n        if (stream.match(/\\.\\.\\./)) { return \"def\"; }\n        /* array list item */\n        if (stream.match(/\\s*-\\s+/)) { return 'meta'; }\n      }\n      /* inline pairs/lists */\n      if (stream.match(/^(\\{|\\}|\\[|\\])/)) {\n        if (ch == '{')\n          state.inlinePairs++;\n        else if (ch == '}')\n          state.inlinePairs--;\n        else if (ch == '[')\n          state.inlineList++;\n        else\n          state.inlineList--;\n        return 'meta';\n      }\n\n      /* list seperator */\n      if (state.inlineList > 0 && !esc && ch == ',') {\n        stream.next();\n        return 'meta';\n      }\n      /* pairs seperator */\n      if (state.inlinePairs > 0 && !esc && ch == ',') {\n        state.keyCol = 0;\n        state.pair = false;\n        state.pairStart = false;\n        stream.next();\n        return 'meta';\n      }\n\n      /* start of value of a pair */\n      if (state.pairStart) {\n        /* block literals */\n        if (stream.match(/^\\s*(\\||\\>)\\s*/)) { state.literal = true; return 'meta'; };\n        /* references */\n        if (stream.match(/^\\s*(\\&|\\*)[a-z0-9\\._-]+\\b/i)) { return 'variable-2'; }\n        /* numbers */\n        if (state.inlinePairs == 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?$/)) { return 'number'; }\n        if (state.inlinePairs > 0 && stream.match(/^\\s*-?[0-9\\.\\,]+\\s?(?=(,|}))/)) { return 'number'; }\n        /* keywords */\n        if (stream.match(keywordRegex)) { return 'keyword'; }\n      }\n\n      /* pairs (associative arrays) -> key */\n      if (!state.pair && stream.match(/^\\s*(?:[,\\[\\]{}&*!|>'\"%@`][^\\s'\":]|[^,\\[\\]{}#&*!|>'\"%@`])[^#]*?(?=\\s*:($|\\s))/)) {\n        state.pair = true;\n        state.keyCol = stream.indentation();\n        return \"atom\";\n      }\n      if (state.pair && stream.match(/^:\\s*/)) { state.pairStart = true; return 'meta'; }\n\n      /* nothing found, continue */\n      state.pairStart = false;\n      state.escaped = (ch == '\\\\');\n      stream.next();\n      return null;\n    },\n    startState: function() {\n      return {\n        pair: false,\n        pairStart: false,\n        keyCol: 0,\n        inlinePairs: 0,\n        inlineList: 0,\n        literal: false,\n        escaped: false\n      };\n    },\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-yaml\", \"yaml\");\nCodeMirror.defineMIME(\"text/yaml\", \"yaml\");\n\n});\n"],"sourceRoot":"webpack:///"}